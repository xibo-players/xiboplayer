/**
 * PlayerCore - Platform-independent orchestration module
 *
 * Pure orchestration logic without platform-specific concerns (UI, DOM, storage).
 * Can be reused across PWA, Electron, mobile platforms.
 *
 * Architecture:
 * ┌─────────────────────────────────────────────────────┐
 * │ PlayerCore (Pure Orchestration)                     │
 * │ - Collection cycle coordination                     │
 * │ - Schedule checking                                 │
 * │ - Layout transition logic                           │
 * │ - Event emission (not DOM manipulation)             │
 * │ - XMDS communication                                │
 * │ - XMR integration                                   │
 * └─────────────────────────────────────────────────────┘
 *                          ↓
 * ┌─────────────────────────────────────────────────────┐
 * │ Platform Layer (PWA/Electron/Mobile)                │
 * │ - UI updates (status display, progress bars)        │
 * │ - DOM manipulation                                  │
 * │ - Platform-specific storage                         │
 * │ - Blob URL management                               │
 * │ - Event listeners for PlayerCore events             │
 * └─────────────────────────────────────────────────────┘
 *
 * Usage:
 *   const core = new PlayerCore({
 *     config,
 *     xmds,
 *     cache,
 *     schedule,
 *     renderer,
 *     xmrWrapper
 *   });
 *
 *   // Listen to events
 *   core.on('collection-start', () => { ... });
 *   core.on('layout-ready', (layoutId) => { ... });
 *
 *   // Start collection
 *   await core.collect();
 */

import { EventEmitter, createLogger, applyCmsLogLevel } from '@xiboplayer/utils';
import { calculateTimeline, parseLayoutDuration } from '@xiboplayer/schedule';
import { CacheAnalyzer } from '@xiboplayer/cache';
import { DataConnectorManager } from './data-connectors.js';

const log = createLogger('PlayerCore');

// IndexedDB database/store for offline cache
const OFFLINE_DB_NAME = 'xibo-offline-cache';
const OFFLINE_DB_VERSION = 1;
const OFFLINE_STORE = 'cache';

/** Extract layout ID from a schedule filename like "123.xlf" */
function parseLayoutFile(f) {
  return parseInt(String(f).replace('.xlf', ''), 10);
}

/** Open the offline cache IndexedDB (creates store on first use) */
function openOfflineDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(OFFLINE_DB_NAME, OFFLINE_DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(OFFLINE_STORE)) {
        db.createObjectStore(OFFLINE_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

export class PlayerCore extends EventEmitter {
  constructor(options) {
    super();

    // Required dependencies (injected)
    this.config = options.config;
    this.xmds = options.xmds;
    this.cache = options.cache;
    this.schedule = options.schedule;
    this.renderer = options.renderer;
    this.XmrWrapper = options.xmrWrapper;
    this.statsCollector = options.statsCollector; // Optional: proof of play tracking
    this.displaySettings = options.displaySettings; // Optional: CMS display settings manager

    // Data connectors manager (real-time data for widgets)
    this.dataConnectorManager = new DataConnectorManager();

    // State
    this.xmr = null;
    this.currentLayoutId = null;
    this.collecting = false;
    this.collectionInterval = null;
    this.pendingLayouts = new Map(); // layoutId -> required media IDs
    this.offlineMode = false; // Track whether we're currently in offline mode
    this._normalCollectInterval = null; // Saved interval to restore after offline retry
    this._offlineRetrySeconds = 0; // Current backoff interval (0 = not retrying)

    // CRC32 checksums for skip optimization (avoid redundant XMDS calls)
    this._lastCheckRf = null;
    this._lastCheckSchedule = null;

    // Layout override state (for changeLayout/overlayLayout via XMR → revertToSchedule)
    this._layoutOverride = null; // { layoutId, type: 'change'|'overlay' }
    this._lastRequiredFiles = []; // Track files for MediaInventory

    // Schedule cycle state (round-robin through multiple layouts)
    this._currentLayoutIndex = 0;

    // Multi-display sync configuration (from RegisterDisplay syncGroup settings)
    this.syncConfig = null;
    this.syncManager = null; // Optional: set via setSyncManager() after RegisterDisplay

    // Layout durations for timeline calculation (layoutFile/layoutId → seconds)
    this._layoutDurations = new Map();

    // Cache analyzer for stale media detection and storage health
    this.cacheAnalyzer = this.cache ? new CacheAnalyzer(this.cache) : null;

    // In-memory offline cache (populated from IndexedDB on first load)
    this._offlineCache = { schedule: null, settings: null, requiredFiles: null };
    this._offlineDbReady = this._initOfflineCache();
  }

  // ── Offline Cache (IndexedDB) ──────────────────────────────────────

  /** Load offline cache from IndexedDB into memory on startup */
  async _initOfflineCache() {
    try {
      const db = await openOfflineDb();
      const tx = db.transaction(OFFLINE_STORE, 'readonly');
      const store = tx.objectStore(OFFLINE_STORE);

      const [schedule, settings, requiredFiles] = await Promise.all([
        new Promise(r => { const req = store.get('schedule'); req.onsuccess = () => r(req.result ?? null); req.onerror = () => r(null); }),
        new Promise(r => { const req = store.get('settings'); req.onsuccess = () => r(req.result ?? null); req.onerror = () => r(null); }),
        new Promise(r => { const req = store.get('requiredFiles'); req.onsuccess = () => r(req.result ?? null); req.onerror = () => r(null); }),
      ]);

      this._offlineCache = { schedule, settings, requiredFiles };
      db.close();
      console.log('[PlayerCore] Offline cache loaded from IndexedDB',
        schedule ? '(has schedule)' : '(empty)');
    } catch (e) {
      console.warn('[PlayerCore] Failed to load offline cache from IndexedDB:', e);
    }
  }

  /** Save a key to both in-memory cache and IndexedDB (fire-and-forget) */
  async _offlineSave(key, data) {
    this._offlineCache[key] = data;
    try {
      const db = await openOfflineDb();
      const tx = db.transaction(OFFLINE_STORE, 'readwrite');
      tx.objectStore(OFFLINE_STORE).put(data, key);
      await new Promise((resolve, reject) => {
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
      });
      db.close();
    } catch (e) {
      console.warn('[PlayerCore] Failed to save offline cache:', key, e);
    }
  }

  /** Check if we have any cached data to fall back on */
  hasCachedData() {
    return this._offlineCache.schedule !== null;
  }

  /** Check if the browser reports being offline */
  isOffline() {
    return typeof navigator !== 'undefined' && navigator.onLine === false;
  }

  /** Check if currently in offline mode */
  isInOfflineMode() {
    return this.offlineMode;
  }

  /**
   * Run an offline collection cycle using cached data.
   * Evaluates the cached schedule and continues playback.
   */
  collectOffline() {
    console.warn('[PlayerCore] Offline mode — using cached schedule');

    if (!this.offlineMode) {
      this.offlineMode = true;
      this.emit('offline-mode', true);
    }

    // Exponential backoff: 30s → 60s → 120s → ... → capped at normal interval
    // Recovers quickly from brief outages but doesn't hammer when truly offline
    if (this.collectionInterval) {
      if (!this._normalCollectInterval) {
        this._normalCollectInterval = this._currentCollectInterval;
        this._offlineRetrySeconds = 30;
      } else {
        // Double the backoff, cap at normal interval
        this._offlineRetrySeconds = Math.min(
          this._offlineRetrySeconds * 2,
          this._normalCollectInterval
        );
      }
      this._setCollectionTimer(this._offlineRetrySeconds);
      log.info(`Offline: retry in ${this._offlineRetrySeconds}s`);
    }

    // Load cached settings for collection interval (first run only)
    if (!this.collectionInterval) {
      const cachedReg = this._offlineCache.settings;
      if (cachedReg?.settings) {
        this.setupCollectionInterval(cachedReg.settings);
        this._normalCollectInterval = this._currentCollectInterval;
        this._offlineRetrySeconds = 30;
        this._setCollectionTimer(this._offlineRetrySeconds);
        log.info(`Offline: retry in ${this._offlineRetrySeconds}s`);
      }
    }

    // Load cached schedule and apply it
    const cachedSchedule = this._offlineCache.schedule;
    if (cachedSchedule) {
      this.schedule.setSchedule(cachedSchedule);
      this.emit('schedule-received', cachedSchedule);
    }

    // Evaluate current schedule
    const layoutFiles = this.schedule.getCurrentLayouts();
    log.info('Offline layouts:', layoutFiles);
    this.emit('layouts-scheduled', layoutFiles);

    this._evaluateAndSwitchLayout(layoutFiles, 'Offline');

    this.emit('collection-complete');
  }

  /**
   * Evaluate the current schedule and switch layouts if needed.
   * Shared by both collect() and collectOffline() after emitting 'layouts-scheduled'.
   * @param {string[]} layoutFiles - Currently scheduled layout filenames
   * @param {string} context - Log context label (e.g. 'Offline' or '')
   */
  async _evaluateAndSwitchLayout(layoutFiles, context) {
    const prefix = context ? `${context}: ` : '';

    if (layoutFiles.length > 0) {
      if (this.currentLayoutId) {
        const currentStillScheduled = layoutFiles.some(f =>
          parseLayoutFile(f) === this.currentLayoutId
        );
        if (currentStillScheduled) {
          const idx = layoutFiles.findIndex(f =>
            parseLayoutFile(f) === this.currentLayoutId
          );
          if (idx >= 0) this._currentLayoutIndex = idx;
          log.debug(`Layout ${this.currentLayoutId} still in schedule${context ? ` (${context.toLowerCase()})` : ''}, continuing playback`);
          this.emit('layout-already-playing', this.currentLayoutId);
        } else {
          this._currentLayoutIndex = 0;
          const next = this.getNextLayout();
          if (next) {
            log.info(`${prefix}switching to layout ${next.layoutId}${!context ? ` (from ${this.currentLayoutId})` : ''}`);
            this.emit('layout-prepare-request', next.layoutId);
          }
        }
      } else {
        this._currentLayoutIndex = 0;
        const next = this.getNextLayout();
        if (next) {
          log.info(`${prefix}switching to layout ${next.layoutId}`);
          this.emit('layout-prepare-request', next.layoutId);
        }
      }
    } else {
      log.info(`${context ? `${context}: n` : 'N'}o layouts${context ? ' in cached schedule' : ' scheduled, falling back to default'}`);
      this.emit('no-layouts-scheduled');
    }

    // Build layout durations and log upcoming timeline
    await this._buildLayoutDurations();
    this.logUpcomingTimeline();
  }

  /**
   * Force an immediate collection (used by platform layer on 'online' event)
   */
  async collectNow() {
    this._lastCheckRf = null;
    this._lastCheckSchedule = null;
    return this.collect();
  }

  /**
   * Start collection cycle
   * Pure orchestration - emits events instead of updating UI
   */
  async collect() {
    // Prevent concurrent collections
    if (this.collecting) {
      log.debug('Collection already in progress, skipping');
      return;
    }

    this.collecting = true;

    try {
      // Ensure offline cache is loaded from IndexedDB before checking
      await this._offlineDbReady;

      log.info('Starting collection cycle...');
      this.emit('collection-start');

      // Check if browser reports offline
      if (this.isOffline()) {
        if (this.hasCachedData()) {
          return this.collectOffline();
        }
        throw new Error('Offline with no cached data — cannot start playback');
      }

      // Ensure RSA key pair exists before registering
      if (this.config.ensureXmrKeyPair) {
        await this.config.ensureXmrKeyPair();
      }

      // Register display
      log.debug('Collection step: registerDisplay');
      const regResult = await this.xmds.registerDisplay();
      log.info('Display registered:', regResult);

      // Cache settings for offline use
      this._offlineSave('settings', regResult);

      // Exit offline mode if we were in it
      if (this.offlineMode) {
        this.offlineMode = false;
        console.log('[PlayerCore] Back online — resuming normal collection');
        this.emit('offline-mode', false);

        // Restore normal collection interval (was shortened for offline retry)
        if (this._normalCollectInterval) {
          this._setCollectionTimer(this._normalCollectInterval);
          this._normalCollectInterval = null;
          this._offlineRetrySeconds = 0;
        }
      }

      // Apply display settings if DisplaySettings manager is available
      if (this.displaySettings && regResult.settings) {
        const result = this.displaySettings.applySettings(regResult.settings);
        if (result.changed.includes('collectInterval')) {
          // Collection interval changed - update interval
          this.updateCollectionInterval(result.settings.collectInterval);
        }

        // Apply CMS logLevel (respects local overrides)
        if (regResult.settings.logLevel) {
          const applied = applyCmsLogLevel(regResult.settings.logLevel);
          if (applied) {
            log.info('Log level updated from CMS:', regResult.settings.logLevel);
            this.emit('log-level-changed', regResult.settings.logLevel);
          }
        }
      }

      // Store sync config if display is in a sync group
      if (regResult.syncConfig) {
        this.syncConfig = regResult.syncConfig;
        log.info('Sync group:', regResult.syncConfig.isLead ? 'LEAD' : `follower → ${regResult.syncConfig.syncGroup}`,
          `(switchDelay: ${regResult.syncConfig.syncSwitchDelay}ms, videoPauseDelay: ${regResult.syncConfig.syncVideoPauseDelay}ms)`);
        this.emit('sync-config', regResult.syncConfig);
      }

      this.emit('register-complete', regResult);

      // Initialize XMR if available
      log.debug('Collection step: initializeXmr');
      await this.initializeXmr(regResult);

      // CRC32 skip optimization: only fetch RequiredFiles/Schedule when CMS data changed
      const checkRf = regResult.checkRf || '';
      const checkSchedule = regResult.checkSchedule || '';

      // Get required files (skip if CRC unchanged)
      if (!this._lastCheckRf || this._lastCheckRf !== checkRf) {
        log.debug('Collection step: requiredFiles');
        const allFiles = await this.xmds.requiredFiles();
        // Separate purge entries from download entries
        const purgeFiles = allFiles.filter(f => f.type === 'purge');
        const files = allFiles.filter(f => f.type !== 'purge');
        log.info('Required files:', files.length, purgeFiles.length > 0 ? `(+ ${purgeFiles.length} purge)` : '');
        this._lastCheckRf = checkRf;
        this.emit('files-received', files);

        // Cache required files for offline use
        this._offlineSave('requiredFiles', allFiles);

        if (purgeFiles.length > 0) {
          this.emit('purge-request', purgeFiles);
        }

        // Get schedule (skip if CRC unchanged)
        if (!this._lastCheckSchedule || this._lastCheckSchedule !== checkSchedule) {
          log.debug('Collection step: schedule');
          const schedule = await this.xmds.schedule();
          log.info('Schedule received');
          this._lastCheckSchedule = checkSchedule;
          log.debug('Collection step: processing schedule');
          this.emit('schedule-received', schedule);
          this.schedule.setSchedule(schedule);
          this.updateDataConnectors();
          this._offlineSave('schedule', schedule);
          this.logUpcomingTimeline();
        }

        log.debug('Collection step: download-request + mediaInventory');
        const currentLayouts = this.schedule.getCurrentLayouts();

        // Layout IDs in playback order (rotated from current index)
        const layoutIds = currentLayouts.map(f => parseLayoutFile(f));
        const layoutOrder = [];
        for (let i = 0; i < layoutIds.length; i++) {
          const idx = (this._currentLayoutIndex + i) % layoutIds.length;
          layoutOrder.push(layoutIds[idx]);
        }

        this._lastRequiredFiles = files;
        this.emit('download-request', { layoutOrder, files });

        // Non-blocking cache analysis (stale media detection)
        if (this.cacheAnalyzer) {
          this.cacheAnalyzer.analyze(files).then(report => {
            this.emit('cache-analysis', report);
          }).catch(err => log.warn('Cache analysis failed:', err));
        }

        // Submit media inventory to CMS (reports cached files)
        this.submitMediaInventory(files);
      } else {
        if (checkRf) {
          log.info('RequiredFiles CRC unchanged, skipping download check');
        }
        if (this._lastCheckSchedule !== checkSchedule) {
          const schedule = await this.xmds.schedule();
          log.info('Schedule received (RF unchanged but schedule changed)');
          this._lastCheckSchedule = checkSchedule;
          this.emit('schedule-received', schedule);
          this.schedule.setSchedule(schedule);
          this.updateDataConnectors();
          this._offlineSave('schedule', schedule);
          this.logUpcomingTimeline();
        } else if (checkSchedule) {
          log.info('Schedule CRC unchanged, skipping');
        }
      }

      log.debug('Collection step: evaluateSchedule');
      // Evaluate current schedule
      const layoutFiles = this.schedule.getCurrentLayouts();
      log.info('Current layouts:', layoutFiles);
      this.emit('layouts-scheduled', layoutFiles);

      this._evaluateAndSwitchLayout(layoutFiles, '');

      // If no layouts scheduled and we're playing one that was filtered (e.g., maxPlaysPerHour),
      // force switch to default layout if available
      if (layoutFiles.length === 0 && this.currentLayoutId && this.schedule.schedule?.default) {
        const defaultLayoutId = parseLayoutFile(this.schedule.schedule.default);
        log.info(`Current layout filtered by schedule, switching to default layout ${defaultLayoutId}`);
        this.currentLayoutId = null; // Clear to force switch
        this.emit('layout-prepare-request', defaultLayoutId);
      }

      // Submit stats if enabled and collector is available
      if (regResult.settings?.statsEnabled === 'On' || regResult.settings?.statsEnabled === '1') {
        if (this.statsCollector) {
          log.info('Stats enabled, submitting proof of play');
          this.emit('submit-stats-request');
        } else {
          log.warn('Stats enabled but no StatsCollector provided');
        }
      }

      // Submit logs to CMS (always, regardless of stats setting)
      this.emit('submit-logs-request');

      // Setup collection interval on first run
      if (!this.collectionInterval && regResult.settings) {
        this.setupCollectionInterval(regResult.settings);
      }

      this.emit('collection-complete');

    } catch (error) {
      // Offline fallback: if network failed but we have cached data, use it
      if (this.hasCachedData()) {
        console.warn('[PlayerCore] Collection failed, falling back to cached data:', error?.message || error);
        this.emit('collection-error', error);
        return this.collectOffline();
      }

      log.error('Collection error:', error);
      this.emit('collection-error', error);
      throw error;
    } finally {
      this.collecting = false;
    }
  }

  /**
   * Initialize XMR WebSocket connection
   */
  async initializeXmr(regResult) {
    const xmrUrl = regResult.settings?.xmrWebSocketAddress || regResult.settings?.xmrNetworkAddress;
    if (!xmrUrl) {
      log.warn('XMR not configured: no xmrWebSocketAddress or xmrNetworkAddress in CMS settings');
      this.emit('xmr-misconfigured', {
        reason: 'missing',
        message: 'XMR address not configured in CMS. Go to CMS Admin → Settings → Configuration → XMR and set the WebSocket address.',
      });
      return;
    }

    // Validate URL protocol — PWA players need ws:// or wss://, not tcp://
    if (xmrUrl.startsWith('tcp://')) {
      log.warn(`XMR address uses tcp:// protocol which is not supported by PWA players: ${xmrUrl}`);
      log.warn('Configure XMR_WS_ADDRESS in CMS Admin → Settings → Configuration → XMR (e.g. wss://your-domain/xmr)');
      this.emit('xmr-misconfigured', {
        reason: 'wrong-protocol',
        url: xmrUrl,
        message: `XMR uses tcp:// protocol (not supported by PWA). Set XMR WebSocket Address to wss://your-domain/xmr in CMS Settings.`,
      });
      return;
    }

    // Detect placeholder/example URLs
    if (/example\.(org|com|net)/i.test(xmrUrl)) {
      log.warn(`XMR address contains placeholder domain: ${xmrUrl}`);
      log.warn('Configure the real XMR address in CMS Admin → Settings → Configuration → XMR');
      this.emit('xmr-misconfigured', {
        reason: 'placeholder',
        url: xmrUrl,
        message: `XMR address is still the default placeholder (${xmrUrl}). Update it in CMS Settings.`,
      });
      return;
    }

    const xmrCmsKey = regResult.settings?.xmrCmsKey || regResult.settings?.serverKey || this.config.serverKey;
    log.debug('XMR CMS Key:', xmrCmsKey ? 'present' : 'missing');

    if (!this.xmr) {
      log.info('Initializing XMR WebSocket:', xmrUrl);
      this.xmr = new this.XmrWrapper(this.config, this);
      await this.xmr.start(xmrUrl, xmrCmsKey);
      this.emit('xmr-connected', xmrUrl);
    } else if (!this.xmr.isConnected()) {
      log.info('XMR disconnected, attempting to reconnect...');
      this.xmr.reconnectAttempts = 0;
      await this.xmr.start(xmrUrl, xmrCmsKey);
      this.emit('xmr-reconnected', xmrUrl);
    } else {
      log.debug('XMR already connected');
    }
  }

  /**
   * Setup collection interval
   */
  setupCollectionInterval(settings) {
    // Use DisplaySettings if available, otherwise fallback to raw settings
    const collectIntervalSeconds = this.displaySettings
      ? this.displaySettings.getCollectInterval()
      : parseInt(settings.collectInterval || '300', 10);

    this._setCollectionTimer(collectIntervalSeconds);
    this.emit('collection-interval-set', collectIntervalSeconds);
  }

  /**
   * Update collection interval dynamically
   * Called when CMS changes the collection interval
   */
  updateCollectionInterval(newIntervalSeconds) {
    if (this.collectionInterval) {
      this._setCollectionTimer(newIntervalSeconds);
      this.emit('collection-interval-updated', newIntervalSeconds);
    }
  }

  /** Internal: (re)create the collection setInterval timer */
  _setCollectionTimer(seconds) {
    if (this.collectionInterval) clearInterval(this.collectionInterval);
    this._currentCollectInterval = seconds;
    log.info(`Collection interval: ${seconds}s`);
    this.collectionInterval = setInterval(() => {
      log.debug('Running scheduled collection cycle...');
      this.collect().catch(error => {
        log.error('Collection error:', error);
        this.emit('collection-error', error);
      });
    }, seconds * 1000);
  }

  /**
   * Request layout change (called by XMR or schedule)
   * Pure orchestration - emits events for platform to handle
   */
  async requestLayoutChange(layoutId) {
    log.info(`Layout change requested: ${layoutId}`);

    // Clear current layout tracking so it will switch
    this.currentLayoutId = null;

    this.emit('layout-change-requested', layoutId);
  }

  /**
   * Mark layout as ready and current
   * Called by platform after it successfully renders the layout
   */
  setCurrentLayout(layoutId) {
    this.currentLayoutId = layoutId;
    this.pendingLayouts.delete(layoutId);
    this.emit('layout-current', layoutId);
    // Re-log timeline from current time on each layout change
    this.logUpcomingTimeline();
  }

  /**
   * Mark layout as pending (waiting for media)
   * Called by platform when layout needs media downloads
   */
  setPendingLayout(layoutId, requiredMediaIds) {
    this.pendingLayouts.set(layoutId, requiredMediaIds);
    this.emit('layout-pending', layoutId, requiredMediaIds);
  }

  /**
   * Clear current layout (for replay)
   * Called by platform when layout ends
   */
  clearCurrentLayout() {
    this.currentLayoutId = null;
    this.emit('layout-cleared');
  }

  /**
   * Get the next layout from the schedule using round-robin cycling.
   * Returns { layoutId, layoutFile } or null if no layouts are scheduled.
   */
  getNextLayout() {
    const layoutFiles = this.schedule.getCurrentLayouts();
    if (layoutFiles.length === 0) {
      return null;
    }

    // Wrap index in case schedule shrank
    if (this._currentLayoutIndex >= layoutFiles.length) {
      this._currentLayoutIndex = 0;
    }

    const layoutFile = layoutFiles[this._currentLayoutIndex];
    const layoutId = parseLayoutFile(layoutFile);
    return { layoutId, layoutFile };
  }

  /**
   * Peek at the next layout in the schedule without advancing the index.
   * Used by the preload system to know which layout to pre-build.
   * Returns { layoutId, layoutFile } or null if no next layout or same as current.
   */
  peekNextLayout() {
    const layoutFiles = this.schedule.getCurrentLayouts();
    if (layoutFiles.length <= 1) {
      // Single layout or empty schedule - no different layout to preload
      return null;
    }

    const nextIndex = (this._currentLayoutIndex + 1) % layoutFiles.length;
    const layoutFile = layoutFiles[nextIndex];
    const layoutId = parseLayoutFile(layoutFile);

    // Don't return if it's the same as current (no point preloading)
    if (layoutId === this.currentLayoutId) {
      return null;
    }

    return { layoutId, layoutFile };
  }

  /**
   * Advance to the next layout in the schedule (round-robin).
   * Called by platform layer when a layout finishes (layoutEnd event).
   * Increments the index and emits layout-prepare-request for the next layout,
   * or triggers replay if only one layout is scheduled.
   */
  advanceToNextLayout() {
    // Don't cycle if we're in a layout override (XMR changeLayout/overlayLayout)
    if (this._layoutOverride) {
      log.info('Layout override active, not advancing schedule');
      return;
    }

    const layoutFiles = this.schedule.getCurrentLayouts();
    log.info(`Advancing schedule: ${layoutFiles.length} layout(s) available, current index ${this._currentLayoutIndex}`);

    // ── Never-stop guarantee ────────────────────────────────────────
    // If no layouts are available at all (every layout is rate-limited
    // or filtered), replay the current layout as a last resort.
    // maxPlaysPerHour is respected in all other cases — this only fires
    // when the alternative would be a blank screen.
    if (layoutFiles.length === 0) {
      if (this.currentLayoutId) {
        log.info(`No layouts available (all rate-limited), replaying ${this.currentLayoutId} to avoid blank screen`);
        const replayId = this.currentLayoutId;
        this.currentLayoutId = null;
        this.emit('layout-prepare-request', replayId);
      } else {
        log.info('No layouts scheduled during advance');
        this.emit('no-layouts-scheduled');
      }
      return;
    }

    // Advance index (wraps around)
    this._currentLayoutIndex = (this._currentLayoutIndex + 1) % layoutFiles.length;

    const layoutFile = layoutFiles[this._currentLayoutIndex];
    const layoutId = parseLayoutFile(layoutFile);

    // Multi-display sync: if this is a sync event and we have a SyncManager,
    // delegate layout transitions to the sync protocol
    if (this.syncManager && this.schedule.isSyncEvent(layoutFile)) {
      if (this.isSyncLead()) {
        // Lead: coordinate with followers before showing
        log.info(`[Sync] Lead requesting coordinated layout change: ${layoutId}`);
        this.syncManager.requestLayoutChange(layoutId).catch(err => {
          log.error('[Sync] Layout change failed:', err);
          // Fallback: show layout anyway
          this.emit('layout-prepare-request', layoutId);
        });
        return;
      } else {
        // Follower: don't advance independently — wait for lead's layout-change signal
        log.info(`[Sync] Follower waiting for lead signal (not advancing independently)`);
        return;
      }
    }

    if (layoutId === this.currentLayoutId) {
      // Same layout (single layout schedule or wrapped back) — trigger replay
      log.info(`Next layout ${layoutId} is same as current, triggering replay`);
      this.currentLayoutId = null; // Clear to allow re-render
    }

    log.info(`Advancing to layout ${layoutId} (index ${this._currentLayoutIndex}/${layoutFiles.length})`);
    this.emit('layout-prepare-request', layoutId);
  }

  /**
   * Go back to the previous layout in the schedule (round-robin, wraps around).
   * Called by platform layer in response to manual navigation (keyboard/remote).
   * Skips sync-manager logic — manual navigation is local only.
   */
  advanceToPreviousLayout() {
    if (this._layoutOverride) {
      log.info('Layout override active, not going back');
      return;
    }

    const layoutFiles = this.schedule.getCurrentLayouts();
    if (layoutFiles.length === 0) return;

    // Decrement index (wrap around)
    const prevIndex = (this._currentLayoutIndex - 1 + layoutFiles.length) % layoutFiles.length;

    const layoutFile = layoutFiles[prevIndex];
    const layoutId = parseLayoutFile(layoutFile);

    // No-op if it's the same layout (single-layout schedule) — don't restart
    if (layoutId === this.currentLayoutId) {
      log.info('Only one layout in schedule, nothing to go back to');
      return;
    }

    this._currentLayoutIndex = prevIndex;
    log.info(`Going back to layout ${layoutId} (index ${this._currentLayoutIndex}/${layoutFiles.length})`);
    this.emit('layout-prepare-request', layoutId);
  }

  /**
   * Notify that a file is ready (called by platform for both layout and media files)
   * Checks if any pending layouts can now be rendered
   */
  notifyMediaReady(fileId, fileType = 'media') {
    log.debug(`File ${fileId} ready (${fileType})`);

    // Check if any pending layouts are now complete
    for (const [layoutId, requiredFiles] of this.pendingLayouts.entries()) {
      // Check if this file is needed by this layout
      // For layout files: match layout ID with file ID (layout 78 needs layout/78)
      // For media files: check if fileId is in requiredFiles array
      const isLayoutFile = fileType === 'layout' && layoutId === parseInt(fileId);
      const isRequiredMedia = fileType === 'media' && requiredFiles.includes(parseInt(fileId));

      if (isLayoutFile || isRequiredMedia) {
        log.debug(`${fileType} ${fileId} was needed by pending layout ${layoutId}, checking if ready...`);
        this.emit('check-pending-layout', layoutId, requiredFiles);
      }
    }
  }

  /**
   * Notify layout status to CMS
   */
  async notifyLayoutStatus(layoutId) {
    try {
      await this.xmds.notifyStatus({ currentLayoutId: layoutId });
      this.emit('status-notified', layoutId);
    } catch (error) {
      log.warn('Failed to notify status:', error);
      this.emit('status-notify-failed', layoutId, error);
    }
  }

  /**
   * Capture screenshot (called by XMR wrapper)
   * Emits event for platform layer to handle
   */
  async captureScreenshot() {
    log.info('Screenshot requested');
    this.emit('screenshot-request');
  }

  /**
   * Change to a specific layout (called by XMR wrapper)
   * Tracks override state so revertToSchedule() can undo it.
   */
  async changeLayout(layoutId) {
    log.info('Layout change requested via XMR:', layoutId);
    this._layoutOverride = { layoutId: parseInt(layoutId, 10), type: 'change' };
    this.currentLayoutId = null; // Force re-render
    this.emit('layout-prepare-request', parseInt(layoutId, 10));
  }

  /**
   * Push an overlay layout on top of current content (called by XMR wrapper)
   * @param {number|string} layoutId - Layout to overlay
   */
  async overlayLayout(layoutId) {
    log.info('Overlay layout requested via XMR:', layoutId);
    this._layoutOverride = { layoutId: parseInt(layoutId, 10), type: 'overlay' };
    this.emit('overlay-layout-request', parseInt(layoutId, 10));
  }

  /**
   * Revert to scheduled content after changeLayout/overlayLayout override
   */
  async revertToSchedule() {
    log.info('Reverting to scheduled content');
    this._layoutOverride = null;
    this.currentLayoutId = null;
    this.emit('revert-to-schedule');

    // Re-evaluate schedule to get the right layout
    const layoutFiles = this.schedule.getCurrentLayouts();
    if (layoutFiles.length > 0) {
      const layoutFile = layoutFiles[0];
      const layoutId = parseLayoutFile(layoutFile);
      this.emit('layout-prepare-request', layoutId);
    } else {
      this.emit('no-layouts-scheduled');
    }
  }

  /**
   * Purge all cached content and re-download (called by XMR wrapper)
   */
  async purgeAll() {
    log.info('Purge all cache requested via XMR');
    this._lastCheckRf = null;
    this._lastCheckSchedule = null;
    this.emit('purge-all-request');
    // Trigger immediate re-collection after purge
    return this.collectNow();
  }

  /**
   * Execute a command (HTTP only in browser context)
   * @param {string} commandCode - The command code from CMS
   * @param {Object} commands - Commands map from display settings
   */
  async executeCommand(commandCode, commands) {
    log.info('Execute command requested:', commandCode);

    if (!commands || !commands[commandCode]) {
      log.warn('Unknown command code:', commandCode);
      this.emit('command-result', { code: commandCode, success: false, reason: 'Unknown command' });
      return;
    }

    const command = commands[commandCode];
    const commandString = command.commandString || command.value || '';

    // Only HTTP commands are possible in a browser
    if (commandString.startsWith('http|')) {
      const parts = commandString.split('|');
      const url = parts[1];
      const contentType = parts[2] || 'application/json';

      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': contentType }
        });
        const success = response.ok;
        log.info(`HTTP command ${commandCode} result: ${response.status}`);
        this.emit('command-result', { code: commandCode, success, status: response.status });
      } catch (error) {
        log.error(`HTTP command ${commandCode} failed:`, error);
        this.emit('command-result', { code: commandCode, success: false, reason: error.message });
      }
    } else {
      log.warn('Non-HTTP commands not supported in browser:', commandCode);
      this.emit('command-result', { code: commandCode, success: false, reason: 'Only HTTP commands supported in browser' });
    }
  }

  /**
   * Trigger a webhook action (called by XMR wrapper)
   * @param {string} triggerCode - The trigger code to fire
   */
  triggerWebhook(triggerCode) {
    log.info('Webhook trigger from XMR:', triggerCode);
    this.handleTrigger(triggerCode);
  }

  /**
   * Force refresh of data connectors (called by XMR wrapper)
   */
  refreshDataConnectors() {
    log.info('Data connector refresh requested via XMR');
    this.dataConnectorManager.refreshAll();
    this.emit('data-connectors-refreshed');
  }

  /**
   * Submit media inventory to CMS
   * Reports which files are cached and complete.
   * @param {Array} files - List of files from RequiredFiles
   */
  async submitMediaInventory(files) {
    if (!files || files.length === 0) return;

    try {
      // Build inventory XML: <files><file type="media" id="1" complete="1" md5="abc" lastChecked="123"/></files>
      const now = Math.floor(Date.now() / 1000);
      const fileEntries = files
        .filter(f => f.type === 'media' || f.type === 'layout')
        .map(f => `<file type="${f.type}" id="${f.id}" complete="1" md5="${f.md5 || ''}" lastChecked="${now}"/>`)
        .join('');
      const inventoryXml = `<files>${fileEntries}</files>`;

      await this.xmds.mediaInventory(inventoryXml);
      log.info(`Media inventory submitted: ${files.length} files`);
      this.emit('media-inventory-submitted', files.length);
    } catch (error) {
      log.warn('MediaInventory submission failed:', error);
    }
  }

  /**
   * BlackList a media file (report broken media to CMS)
   * @param {string|number} mediaId - The media ID
   * @param {string} type - File type ('media' or 'layout')
   * @param {string} reason - Reason for blacklisting
   */
  async blackList(mediaId, type, reason) {
    try {
      await this.xmds.blackList(mediaId, type, reason);
      this.emit('media-blacklisted', { mediaId, type, reason });
    } catch (error) {
      log.warn('BlackList failed:', error);
    }
  }

  /**
   * Check if currently in a layout override (from XMR changeLayout/overlayLayout)
   */
  isLayoutOverridden() {
    return this._layoutOverride !== null;
  }

  /**
   * Handle interactive trigger (from IC or touch events)
   * Looks up matching action in schedule and executes it
   * @param {string} triggerCode - The trigger code from the IC request
   */
  handleTrigger(triggerCode) {
    const action = this.schedule.findActionByTrigger(triggerCode);
    if (!action) {
      log.debug('No scheduled action matches trigger:', triggerCode);
      return;
    }

    log.info(`Action triggered: ${action.actionType} (trigger: ${triggerCode})`);

    switch (action.actionType) {
      case 'navLayout':
      case 'navigateToLayout':
        if (action.layoutCode) {
          this.changeLayout(action.layoutCode);
        }
        break;
      case 'navWidget':
      case 'navigateToWidget':
        this.emit('navigate-to-widget', action);
        break;
      case 'command':
        this.emit('execute-command', action.commandCode);
        break;
      default:
        log.warn('Unknown action type:', action.actionType);
    }
  }

  /**
   * Update data connectors from current schedule
   * Reconfigures and restarts polling when schedule changes.
   */
  updateDataConnectors() {
    const connectors = this.schedule.getDataConnectors();

    if (connectors.length > 0) {
      log.info(`Configuring ${connectors.length} data connector(s)`);
    }

    this.dataConnectorManager.setConnectors(connectors);

    if (connectors.length > 0) {
      this.dataConnectorManager.startPolling();
      this.emit('data-connectors-started', connectors.length);
    }
  }

  /**
   * Get the DataConnectorManager instance
   * Used by platform layer to serve data to widgets via IC /realtime
   * @returns {DataConnectorManager}
   */
  getDataConnectorManager() {
    return this.dataConnectorManager;
  }

  /**
   * Set the SyncManager instance for multi-display coordination.
   * Called by platform layer after RegisterDisplay returns syncConfig.
   *
   * @param {SyncManager} syncManager - SyncManager instance
   */
  setSyncManager(syncManager) {
    this.syncManager = syncManager;
    log.info('SyncManager attached:', syncManager.isLead ? 'LEAD' : 'FOLLOWER');
  }

  /**
   * Check if this display is part of a sync group
   * @returns {boolean}
   */
  isInSyncGroup() {
    return this.syncConfig !== null;
  }

  /**
   * Check if this display is the sync group leader
   * @returns {boolean}
   */
  isSyncLead() {
    return this.syncConfig?.isLead === true;
  }

  /**
   * Get sync configuration
   * @returns {Object|null} { syncGroup, syncPublisherPort, syncSwitchDelay, syncVideoPauseDelay, isLead }
   */
  getSyncConfig() {
    return this.syncConfig;
  }

  // ── Timeline (offline schedule prediction) ─────────────────────────

  /**
   * Parse all cached layout XLFs to extract durations for timeline calculation.
   * Called after collection completes and layouts are known.
   */
  async _buildLayoutDurations() {
    if (!this.cache?.getFile) return; // Cache doesn't support direct file access

    const layoutFiles = this.schedule.getCurrentLayouts();
    const defaultFile = this.schedule.schedule?.default;
    const allFiles = [...new Set([...layoutFiles, ...(defaultFile ? [defaultFile] : [])])];

    let parsed = 0;
    for (const file of allFiles) {
      const layoutId = parseLayoutFile(file);
      try {
        const xlfXml = await this.cache.getFile('layout', layoutId);
        if (xlfXml) {
          const duration = parseLayoutDuration(xlfXml);
          this._layoutDurations.set(file, duration);
          this._layoutDurations.set(String(layoutId), duration);
          parsed++;
        }
      } catch (e) {
        log.debug(`Could not parse duration for layout ${layoutId}:`, e.message);
      }
    }
    if (parsed > 0) {
      log.info(`[Timeline] Parsed durations for ${parsed} layouts`);
    }
  }

  /**
   * Calculate and log the upcoming playback timeline (next 2 hours).
   * Emits 'timeline-updated' with the full timeline array.
   */
  logUpcomingTimeline() {
    if (this._layoutDurations.size === 0) return;
    if (!this.schedule.getLayoutsAtTime) return; // Schedule doesn't support time queries

    const timeline = calculateTimeline(this.schedule, this._layoutDurations);
    if (timeline.length === 0) return;

    const lines = timeline.slice(0, 20).map(e => {
      const s = e.startTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      const end = e.endTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      return `  ${s}-${end}  Layout ${e.layoutFile} (${e.duration}s)${e.isDefault ? ' [default]' : ''}`;
    });
    log.info(`[Timeline] Next ${timeline.length} plays:\n${lines.join('\n')}`);
    this.emit('timeline-updated', timeline);
  }

  /**
   * Record/correct a layout's actual duration (e.g., from video loadedmetadata).
   * Updates the durations map and re-logs the timeline if it changed.
   * @param {string} file - Layout file or layout ID string
   * @param {number} duration - Actual duration in seconds
   */
  recordLayoutDuration(file, duration) {
    const prev = this._layoutDurations.get(file);
    if (prev === duration) return; // No change

    this._layoutDurations.set(file, duration);
    log.debug(`[Timeline] Duration corrected: layout ${file} ${prev || '?'}s → ${duration}s`);
    this.logUpcomingTimeline();
  }

  /**
   * Cleanup
   */
  cleanup() {
    if (this.collectionInterval) {
      clearInterval(this.collectionInterval);
      this.collectionInterval = null;
    }

    if (this.xmr) {
      this.xmr.stop();
      this.xmr = null;
    }

    // Stop multi-display sync
    if (this.syncManager) {
      this.syncManager.stop();
      this.syncManager = null;
    }

    // Stop data connector polling
    this.dataConnectorManager.cleanup();

    // Emit cleanup-complete before removing listeners
    this.emit('cleanup-complete');
    this.removeAllListeners();
  }

  /**
   * Get current layout ID
   */
  getCurrentLayoutId() {
    return this.currentLayoutId;
  }

  /**
   * Check if collecting
   */
  isCollecting() {
    return this.collecting;
  }

  /**
   * Get pending layouts
   */
  getPendingLayouts() {
    return Array.from(this.pendingLayouts.keys());
  }

}
